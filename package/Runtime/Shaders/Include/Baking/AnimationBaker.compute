#pragma kernel BakeAnimationTexture_Float4
#pragma kernel BakeBoneWeights

#include "AnimationBakingStructs.cginc"

StructuredBuffer<float4x4> Matrices;
RWTexture2D<float4> Texture;

/*
 *  Texture Data Layout:
 *  
 *  pixel_n: Mat_Col0
 *  pixel_n+1: Mat_Col1
 *  pixel_n+2: Mat_Col2
 *  pixel_n+3: Mat_Col3
 **/

[numthreads(32,1,1)]
void BakeAnimationTexture_Float4(uint3 _id : SV_DispatchThreadID)
{
    const uint id = _id.x; // because each matrix takes 4 pixel
    uint matrixCount, stride;
    Matrices.GetDimensions(matrixCount, stride);
    const uint matrixIndex = id;
    if(matrixIndex >= matrixCount) return;
    float4x4 mat = Matrices[matrixIndex];
    uint tw, th;
    Texture.GetDimensions(tw, th);
    const uint index = matrixIndex * 4;
    [unroll]
    for(uint i = index; i < index + 4; i += 1)
    {
        int x = i % tw;
        int y = floor(i / (float)th);
        Texture[uint2(x,y)] = mat[i];
    }
}


StructuredBuffer<BoneWeight> Weights;

void Write(uint index, uint textureWidth, uint textureHeight, float4 values)
{
    int x = index % textureWidth;
    int y = floor(index / (float)textureHeight);
    uint2 coord = uint2(x,y);
    Texture[coord] = values;// 1 - (float)x / textureWidth;// values;
}

[numthreads(32,1,1)]
void BakeBoneWeights(uint3 _id : SV_DispatchThreadID)
{
    const uint weightIndex = _id.x;
    uint weightsCount, stride;
    Weights.GetDimensions(weightsCount, stride);
    if(weightIndex >= weightsCount) return;
    uint tw, th;
    Texture.GetDimensions(tw, th);
    BoneWeight weight = Weights[weightIndex];
    const int textureIndex = weightIndex * 2; // because we store a weight into two pixels
    float4 skin01 = float4(weight.weight0, weight.boneIndex0, weight.weight1, weight.boneIndex1);
    float4 skin23 = float4(weight.weight2, weight.boneIndex2, weight.weight3, weight.boneIndex3);
    Write(textureIndex, tw, th, skin01);
    Write(textureIndex+1, tw, th, skin23);
}