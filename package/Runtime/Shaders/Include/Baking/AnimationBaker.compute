#pragma kernel BakeAnimationTexture_Float4
#pragma kernel BakeBoneWeights

#include "AnimationBakingStructs.cginc"

StructuredBuffer<float4x4> Matrices;
RWTexture2D<float4> Texture;

/*
 *  Texture Data Layout:
 *  
 *  pixel_n: Mat_Col0
 *  pixel_n+1: Mat_Col1
 *  pixel_n+2: Mat_Col2
 *  pixel_n+3: Mat_Col3
 **/

[numthreads(32,1,1)]
void BakeAnimationTexture_Float4(uint3 _id : SV_DispatchThreadID)
{
    const uint id = _id.x; // because each matrix takes 4 pixel
    uint matrixCount, stride;
    Matrices.GetDimensions(matrixCount, stride);
    const uint matrixIndex = id;
    if(matrixIndex >= matrixCount) return;
    float4x4 mat = Matrices[matrixIndex];
    uint tw, th;
    Texture.GetDimensions(tw, th);
    const uint index = matrixIndex * 4;
    [unroll]
    for(uint i = index; i < index + 4; i += 1)
    {
        int x = i % tw;
        int y = floor(i / (float)th);
        Texture[uint2(x,y)] = mat[i];
    }
}


StructuredBuffer<BoneWeight> Weights;

void Write(uint index, float4 values, uint textureWidth, uint textureHeight)
{
    int x = index % textureWidth;
    int y = floor(index / (float)textureHeight);
    Texture[uint2(x,y)] = values;
}

[numthreads(32,1,1)]
void BakeBoneWeights(uint3 _id : SV_DispatchThreadID)
{
    const uint weightIndex = _id.x;
    uint weightsCount, stride;
    Weights.GetDimensions(weightsCount, stride);
    if(weightIndex >= weightsCount) return;
    uint tw, th;
    Texture.GetDimensions(tw, th);
    BoneWeight weight = Weights[weightIndex];
    const int textureIndex = weightIndex * 2; // because we store a weight into two pixels
    Write(textureIndex, float4(weight.weight0, weight.boneIndex0, weight.weight1, weight.boneIndex1), tw, th);
    Write(textureIndex+1, float4(weight.weight2, weight.boneIndex2, weight.weight3, weight.boneIndex3), tw, th);
}